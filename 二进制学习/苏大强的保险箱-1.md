## 苏大强的保险箱-1

### 题目来源：

[ISCC2020 RE](https://github.com/lxwAsm/CTF/blob/master/re/苏大强的保险箱-1.exe)



### 运行程序观察程序特征

运行程序，随意输入，可得到下图：

![图1](D:\二进制学习\苏大强的保险箱-1\1.PNG)

由上图可知，程序基本逻辑很简单，在 命令行 按照提示 密码即可，随意输入 123456 可得到 **关键字符串“Wrong!Please try again!”**

***同样从上图可知，不需要输入Name，直接输入密码；可以推测该密码多半为固定字符串吗，已经存储在数据段，与输入的开箱密码进行对比；所以要注意查看程序运行中出现的固定字符串***

### 使用查壳工具进行查壳

根据信息可知这个程序无壳，对这部不甚了解，所以不展开了



### 分析步骤

- 将程序拖入X64DGB或者OD
- 右键->搜索->所有模块->字符串  ；然后搜索上述所说关键字符串，对他们下断点；双击进入第一个关键字符串所在的位置

![图2](D:\二进制学习\苏大强的保险箱-1\2.png)

- 第一个字符串的位置即为 标号为1 处
- 观察下方内容 标号为2处   可以看到重要的提示部分  说明当开箱密码输入正确时，会显示 Flag  和Key
- 在OD中运行  会先运行 下方标号为3的部分
- 注意 标号为4 的地方 出现了可疑的固定字符串， 尝试输入程序后发现并不是密码，保留观察
- 从标号为3处 单步运行，发现了标号为4  明显可知 取得输入的密码长度和 0xA对比 说明 密码长度要求为 10

F8单步运行 发现关键 比较函数，位于 00401709  F7单步步入该函数

![图3](D:\二进制学习\苏大强的保险箱-1\3.png)



进入该函数后得到如下图所示该函数 中 有多轮 循环；可单步F8进行分析 或者整体分析  判断 0040151为关键的 判断 部分，光标点击该处F4 ，运行到光标处；意外发现出现了固定字符串 信息量极为丰富，下图标号为2 长度为10 即为可能是 密码



![图4](D:\二进制学习\苏大强的保险箱-1\4.png)



**将标号为2的字符串输入程序，发现并不是正确密码，对比标号1 发现原本缩入的 0123456789被翻转倒置，所以推测正确的密码 为该字符串的倒置**



尝试输入 可得：

![图5](D:\二进制学习\苏大强的保险箱-1\5.PNG)





#### 算法逆向

根据上述找的关键位置，将程序拖入IDA ，找到该位置，F5得到

![图6](D:\二进制学习\苏大强的保险箱-1\6.PNG)



```c++
#include <iostream>
#include <string>
using namespace std;

int main(){
	char a[10]={0x0A,0x7,0x41,0x0B,0x2C,0x0C,0x3D,0x38,0x27,0x73};
	char b[10]={0xD5,0x9E,0xB4,0x70,0x78,0x60,0x82,0x70,0x39,0x5E};
	string s="";
	for(int i=0;i<10;i++){
	   s+=b[9-i]-i-a[i]	;
	}
	
	//字符串逆序输出 
	for(int i =s.size();i>=0;i--){
		cout<<s[i];
	}
	return 0;
}
```



**注意 key值  ：a1dWT1pJXF1USVxRV1ZbUElQSVBJ**



